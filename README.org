#+TITLE: Game Sandbox

A live editing framework for game prototyping in JavaScript.

* Features
  - Hot code reloading.
  - Maintains state between reloads.
  - Lightweight game utils library.

* Installation
#+begin_src sh
  $ npm install game-sandbox
#+end_src

* Quick Start
Create a new npm project, install the npm ~game-sandbox~ module and create a skeleton project:
#+begin_src sh
  $ mkdir mygame
  $ cd mygame
  $ npm init -y
  $ npm install game-sandbox
  $ game-sandbox init
#+end_src

Start the server:
#+begin_src sh
  $ game-sandbox start \
      --watch \
      --base-dir src \
      --watch-dir src/game \
      --output-dir dist
#+end_src

Point your browser to ~http://localhost:8080~, and start modifying the source in ~src/game/index.js~.

* How it works

The ~runGame()~ function is the entry point of your game. It is called like this:
#+begin_src js
    import { runGame } from '/game-sandbox';

    runGame({
      width: 400,
      height: 400,
      canvasId: 'game-canvas',
      moduleUrl: './mygame.js',
    });
#+end_src

The game logic is defined inside two functions: ~setup()~ and ~draw()~, which must be exported by the
module defined in the ~moduleUrl~ attribute passed to ~runGame()~.

Once started, the Game Sandbox server watches the directory specified in the ~watch-dir~ option. When
a file is changed, it generates a bundle with the game code and notifies the browser. The browser
then reloads the ~draw()~ function between frames so your game is updated seamlessly.

* How it works

Game Sandbox is inspired by [[https://github.com/Schmavery/reprocessing][Reprocessing]], which in turn is influenced by [[https://processing.org/][Processing]]. The main idea
is the game state is separated from the game logic, which helps performing reloads without resetting
the game.

Before the main loop is executed, the ~setup()~ function returns the initial game state, and then the
~draw()~ function returns an updated state every frame. The game state is just an object with
attributes that represent your game, such as the player's position, etc.

The ~draw()~ function has two parameters, the current game state and an ~Environment~ object, which
contains attributes such as the game width and height, a reference to the canvas context, or the
user input.


** Example
#+begin_src js
  export function setup(env) {
    return {
      x: 100,
      y: 100,
      speed: 10,
    };
  }

  export function draw(state, env) {

    let { input, ctx, width, height } = env;

    if (input.right) {
      state.x = Math.min(width, state.x + state.speed);
    }

    if (input.left) {
      state.x = Math.max(0, state.x - state.speed);
    }

    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(state.x, state.y, 10, 0, Math.PI * 2)
    ctx.fill()


    return state;
  }
#+end_src
