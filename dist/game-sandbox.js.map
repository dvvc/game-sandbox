{
  "version": 3,
  "sources": ["../lib/input.js", "../lib/hud.js", "../lib/recorder.js", "../lib/engine.js"],
  "sourcesContent": ["// KeyboardEvent#code -> input key\nconst KEY_MAP = {\n  ArrowRight: 'right',\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  KeyX: 'b1',\n  KeyZ: 'b2',\n};\n\nconst ENGINE_KEY_MAP = {\n  Backquote: 'hud',\n  Enter: 'enter',\n};\n\n/**\n * Register input event handlers\n *\n */\nexport function initInput() {\n  let currentInput = {};\n  let currentInputP = {};\n  let engineCurrentInput = {};\n  let engineCurrentInputP = {};\n\n  document.addEventListener('keydown', e => {\n    let key;\n\n    if ((key = KEY_MAP[e.code])) {\n      let keyp = key + 'p';\n\n      currentInput[key] = true;\n      currentInputP[keyp] = true;\n    } else if ((key = ENGINE_KEY_MAP[e.code])) {\n      let keyp = key + 'p';\n      engineCurrentInput[key] = true;\n      engineCurrentInputP[keyp] = true;\n    }\n  });\n\n  document.addEventListener('keyup', e => {\n    let key;\n\n    if ((key = KEY_MAP[e.code])) {\n      currentInput[key] = false;\n    } else if ((key = ENGINE_KEY_MAP[e.code])) {\n      engineCurrentInput[key] = false;\n    }\n  });\n\n  return {\n    currentInput,\n    currentInputP,\n    engineCurrentInput,\n    engineCurrentInputP,\n  };\n}\n\n/**\n * Copy the transient input (as read from the DOM) into the env input.\n *\n */\nexport function readInput(env) {\n  let input = env.engine.input;\n  env.input = Object.assign({}, input.currentInput, input.currentInputP);\n}\n\n/**\n * Same as read input, but only for internal input\n * This is necessary when we want to keep reading the system's input while playing a recording,\n * since we don't read user input then\n */\nexport function readInternalInput(env) {\n  let input = env.engine.input;\n  env.engine.internalInput = Object.assign({}, input.engineCurrentInput, input.engineCurrentInputP);\n}\n\n/**\n * Set all input keypresses to false, so that attribute can be used to detect the frame when the\n * key was initially pressed.\n *\n */\nexport function clearFrameInput(internalInput) {\n  Object.keys(internalInput.currentInputP).forEach(k => {\n    internalInput.currentInputP[k] = false;\n  });\n  Object.keys(internalInput.engineCurrentInputP).forEach(k => {\n    internalInput.engineCurrentInputP[k] = false;\n  });\n}\n", "const HUD_COMMANDS = ['Start recording', 'Play recording', 'Stop recording'];\n\nconst COMMAND_BG = '#555555';\nconst COMMAND_FG = '#eeeeee';\n\nfunction setHudBoundingBox(hudElement, boundingBox) {\n  hudElement.style.top = boundingBox.top + 'px';\n  hudElement.style.left = boundingBox.left + 'px';\n  hudElement.style.width = boundingBox.width + 'px';\n  hudElement.style.height = boundingBox.height + 'px';\n}\n\nfunction buildHudElement(boundingBox) {\n  let hudElement = document.createElement('div');\n  hudElement.style.position = 'absolute';\n  setHudBoundingBox(hudElement, boundingBox);\n  hudElement.style.backgroundColor = COMMAND_BG;\n  hudElement.style.opacity = 0;\n  hudElement.style.transition = 'opacity 0.3s ease';\n\n  let hudCommandList = document.createElement('ul');\n  hudCommandList.style.color = COMMAND_FG;\n  hudCommandList.style.listStyle = 'none';\n  hudCommandList.style.padding = '0 20px';\n  hudCommandList.style.marginTop = '40px';\n  hudCommandList.style.fontFamily = 'monospace';\n\n  HUD_COMMANDS.forEach(cmd => {\n    let commandItem = document.createElement('li');\n    commandItem.innerHTML = cmd;\n    commandItem.style.lineHeight = 1.6;\n    commandItem.style.padding = '2px 10px';\n    hudCommandList.appendChild(commandItem);\n  });\n\n  // Highlight the first element\n  hudCommandList.children.item(0).style.backgroundColor = COMMAND_FG;\n  hudCommandList.children.item(0).style.color = COMMAND_BG;\n\n  hudElement.appendChild(hudCommandList);\n\n  return hudElement;\n}\n\n/**\n * Initialize the HUD, create the HTML code\n *\n */\nexport function initHud(canvasBoundingBox) {\n  let hudElement = buildHudElement(canvasBoundingBox);\n  document.body.appendChild(hudElement);\n\n  return {\n    active: false,\n    selectedCommand: 0,\n    element: hudElement,\n  };\n}\n\nexport function toggleHud(hud, canvasBoundingBox) {\n  hud.active = !hud.active;\n  if (hud.active) {\n    setHudBoundingBox(hud.element, canvasBoundingBox);\n  }\n  hud.element.style.opacity = Number(hud.active);\n}\n\nfunction updateHudCommandSelection(hud, input) {\n  // update the selected command if the arrows were pressed\n  let newCommandIndex = hud.selectedCommand;\n\n  if (input.downp) {\n    newCommandIndex = (hud.selectedCommand + 1) % HUD_COMMANDS.length;\n  } else if (input.upp) {\n    newCommandIndex = (hud.selectedCommand - 1 + HUD_COMMANDS.length) % HUD_COMMANDS.length;\n  }\n\n  if (newCommandIndex !== hud.selectedCommand) {\n    let commandList = hud.element.firstChild;\n\n    // remove background of old command\n    commandList.children.item(hud.selectedCommand).style.backgroundColor = null;\n    commandList.children.item(hud.selectedCommand).style.color = COMMAND_FG;\n\n    // set background of new command\n    commandList.children.item(newCommandIndex).style.backgroundColor = COMMAND_FG;\n    commandList.children.item(newCommandIndex).style.color = COMMAND_BG;\n\n    hud.selectedCommand = newCommandIndex;\n  }\n}\n\nexport function updateHud(hud, internalInput, input) {\n  // check if the current command has been selected\n  if (internalInput.enterp) {\n    return hud.selectedCommand;\n  }\n\n  // Otherwise, update the selection if necessary\n  updateHudCommandSelection(hud, input);\n}\n", "const MAX_RECORDER_SIZE = 60 * 60 * 5; // 60 FPS * 60 secs/min * 5 mins\n\nexport function initRecorder() {\n  return {\n    recording: false,\n    playing: false,\n    currentInput: 0,\n    stateSnapshot: undefined,\n    inputHistory: [],\n  };\n}\n\nexport function startRecording(env, updatedState) {\n  let recorder = env.engine.recorder;\n  recorder.recording = true;\n  recorder.stateSnapshot = updatedState;\n  recorder.playing = false;\n  recorder.currentInput = 0;\n  recorder.stateSnapshot = { ...updatedState }; // FIXME: This is a shallow copy!\n  recorder.inputHistory = [];\n}\n\nexport function playRecording(env) {\n  let recorder = env.engine.recorder;\n  stopRecording(env);\n\n  recorder.playing = true;\n  recorder.currentInput = 0;\n}\n\nexport function stopRecording(env) {\n  let recorder = env.engine.recorder;\n  recorder.recording = false;\n}\n\nexport function playInputHistory(env) {\n  let recorder = env.engine.recorder;\n  if (!recorder.playing) {\n    throw new Error(`Tried to play input history, but recorder is not playing`);\n  }\n\n  if (recorder.inputHistory === 0) {\n    throw new Error(`Recorder input history is empty!!`);\n  }\n\n  let input = recorder.inputHistory[recorder.currentInput];\n  recorder.currentInput = (recorder.currentInput + 1) % recorder.inputHistory.length;\n  return input;\n}\n\nexport function recordInput(recorder, input) {\n  if (!recorder.recording) {\n    throw new Error(`Tried to record input, but recorder is not recording`);\n  }\n\n  recorder.inputHistory.push({ ...input });\n\n  // FIXME: Do something about this\n  if (recorder.inputHistory.length > MAX_RECORDER_SIZE) {\n    throw new Error(`Max record input exceeded!!`);\n  }\n}\n\n// export function processRecording(env) {}\n", "import { initInput, readInput, readInternalInput, clearFrameInput } from './input.js';\nimport { initHud, toggleHud, updateHud } from './hud.js';\nimport {\n  initRecorder,\n  startRecording,\n  playRecording,\n  stopRecording,\n  playInputHistory,\n  recordInput,\n} from './recorder.js';\n\nconst OPT_DEFAULTS = {\n  width: 600,\n  height: 600,\n  canvasId: 'canvas',\n};\n\n/**\n * Initializes the internal data in the environment\n *\n */\nfunction initEngine(canvasEl) {\n  return {\n    initialized: false,\n    recorder: initRecorder(),\n    input: initInput(),\n    hud: initHud(canvasEl.getBoundingClientRect()),\n    canvasEl,\n  };\n}\n\n/**\n * Initialize the environment\n *\n *  - Set the canvas size\n *  - Store the canvas context\n *  - Initialize environment data\n *  - Register keyboard handlers\n */\nfunction initEnv(opts) {\n  let { width, height, canvasId } = opts;\n\n  let canvasEl = document.getElementById(canvasId);\n  let ctx = canvasEl.getContext('2d');\n\n  // Scale the ctx to respect the pixel ratio\n  let dpr = window.devicePixelRatio || 1;\n\n  canvasEl.width = width * dpr;\n  canvasEl.height = height * dpr;\n\n  canvasEl.style.width = width + 'px';\n  canvasEl.style.height = height + 'px';\n\n  ctx.scale(dpr, dpr);\n\n  return {\n    ctx,\n    width,\n    height,\n    input: {},\n    delta: 0,\n    engine: initEngine(canvasEl),\n  };\n}\n\n/**\n * Declares the game loop and starts it\n *\n */\nfunction initGame(state, env) {\n  let updatedState = state;\n  let lastTime = 0;\n\n  let hud = env.engine.hud;\n  let canvasEl = env.engine.canvasEl;\n  let recorder = env.engine.recorder;\n\n  (function gameLoop(time) {\n    // Calculate how many milliseconds passed since last frame\n    env.delta = (time - lastTime) / 1000;\n\n    // Read this frame's input\n    if (recorder.playing) {\n      env.input = playInputHistory(env);\n      // if we reached the first input entry, reset the state\n      // Note currentInput is 1 when we have returned input 0\n      if (recorder.currentInput === 1) {\n        updatedState = { ...recorder.stateSnapshot };\n      }\n    } else {\n      readInput(env);\n    }\n\n    // Read internal input even if we are playing a recording\n    readInternalInput(env);\n\n    if (recorder.recording && !hud.active) {\n      recordInput(recorder, env.input);\n    }\n\n    if (env.engine.internalInput.hudp) {\n      toggleHud(hud, canvasEl.getBoundingClientRect());\n    }\n\n    if (hud.active) {\n      // If hud is open, do not draw the game, instead process hud events\n      let selectedCommand = updateHud(hud, env.engine.internalInput, env.input);\n      if (selectedCommand !== undefined) {\n        // A command was executed\n        // Deactivate hud\n        toggleHud(hud, canvasEl.getBoundingClientRect());\n        // Apply command\n        // FIXME: This requires knowledge of HUD Commands. Instead, register functions or something\n        // like that?\n        if (selectedCommand === 0) {\n          // start recording\n          startRecording(env, updatedState);\n        } else if (selectedCommand === 1) {\n          // stop recording and play\n          playRecording(env);\n          updatedState = { ...recorder.stateSnapshot };\n        } else if (selectedCommand === 2) {\n          stopRecording(env);\n        }\n      }\n    } else {\n      // Run user's defined draw function\n      updatedState = env.engine.draw(updatedState, env);\n    }\n\n    // Clear transient input for this frame\n    clearFrameInput(env.engine.input);\n    lastTime = time;\n    window.requestAnimationFrame(gameLoop);\n  })(0);\n}\n\n/**\n * Create a new web socket connection to the server, passing the entry point of the game. When the\n * server detects a change and notifies through the websocket, re-import a new version of the module\n * and replace the draw / setup functions with the updated ones.\n *\n */\nfunction startGameClient(moduleUrl, env) {\n  let protocol = location.protocol === 'https' ? 'wss' : 'ws';\n  let ws = new WebSocket(`${protocol}://${location.host}?module=${moduleUrl}`);\n\n  ws.addEventListener('message', async event => {\n    let [action, file] = event.data.split(':');\n\n    if (action === 'change' || action === 'rebuild') {\n      // When a chage is detected, re-import the game bundle\n\n      // The try block is just to silence esbuild when bundling the distributable\n      let module;\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        module = await import(file + '?t=' + new Date().getTime());\n      } catch (e) {\n        throw e;\n      }\n\n      if (!module.setup || !module.draw) {\n        throw new Error(`Invalid module at ${file}`);\n      }\n\n      let engine = env.engine;\n\n      // Update the setup / draw functions with the new ones\n      engine.setup = module.setup;\n      engine.draw = module.draw;\n\n      // After the first update, if the client was not initialized, we start the game\n      if (!engine.initialized) {\n        let state = engine.setup(env);\n\n        engine.initialized = true;\n        // game loop\n        initGame(state, env);\n      }\n    }\n  });\n}\n\n/**\n * Starts the game. Options\n *\n *   witdth:    The game width\n *   height:    The game height\n *   canvasId:  The id of the HTML canvas element\n *   moduleUrl: The path to the game module entry point (relative to the watch-dir parameter)\n *\n */\nexport async function runGame(opts) {\n  opts = Object.assign({}, OPT_DEFAULTS, opts);\n\n  if (!opts.moduleUrl) {\n    throw new Error(`Must provide a moduleUrl`);\n  }\n\n  // wait until the DOM is loaded, then start\n  window.addEventListener('load', () => {\n    let env = initEnv(opts);\n    startGameClient(opts.moduleUrl, env);\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
