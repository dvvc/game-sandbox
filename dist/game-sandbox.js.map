{
  "version": 3,
  "sources": ["../lib/input.js", "../lib/hud.js", "../lib/assets.js", "../lib/recorder.js", "../lib/engine.js", "../lib/animations.js"],
  "sourcesContent": ["// KeyboardEvent#code -> input key\nconst KEY_MAP = {\n  ArrowRight: 'right',\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  KeyX: 'b1',\n  KeyZ: 'b2',\n};\n\nconst ENGINE_KEY_MAP = {\n  Backquote: 'hud',\n  Enter: 'enter',\n};\n\n/**\n * Register input event handlers\n *\n */\nexport function initInput() {\n  let currentInput = {};\n  let currentInputP = {};\n  let engineCurrentInput = {};\n  let engineCurrentInputP = {};\n\n  document.addEventListener('keydown', e => {\n    let key;\n\n    if ((key = KEY_MAP[e.code])) {\n      let keyp = key + 'p';\n\n      currentInput[key] = true;\n      currentInputP[keyp] = true;\n    } else if ((key = ENGINE_KEY_MAP[e.code])) {\n      let keyp = key + 'p';\n      engineCurrentInput[key] = true;\n      engineCurrentInputP[keyp] = true;\n    }\n  });\n\n  document.addEventListener('keyup', e => {\n    let key;\n\n    if ((key = KEY_MAP[e.code])) {\n      currentInput[key] = false;\n    } else if ((key = ENGINE_KEY_MAP[e.code])) {\n      engineCurrentInput[key] = false;\n    }\n  });\n\n  return {\n    currentInput,\n    currentInputP,\n    engineCurrentInput,\n    engineCurrentInputP,\n  };\n}\n\n/**\n * Copy the transient input (as read from the DOM) into the env input.\n *\n */\nexport function readInput(env) {\n  let input = env.engine.input;\n  env.input = Object.assign({}, input.currentInput, input.currentInputP);\n  env.engine.internalInput = Object.assign({}, input.engineCurrentInput, input.engineCurrentInputP);\n}\n\n/**\n * Same as read input, but only for internal input\n * This is necessary when we want to keep reading the system's input while playing a recording,\n * since we don't read user input then\n *\n * TODO: DELETE ME!!!\n */\nexport function readInternalInput(env) {\n  let input = env.engine.input;\n  env.engine.internalInput = Object.assign({}, input.engineCurrentInput, input.engineCurrentInputP);\n}\n\n/**\n * Set all input keypresses to false, so that attribute can be used to detect the frame when the\n * key was initially pressed.\n *\n */\nexport function clearFrameInput(internalInput) {\n  Object.keys(internalInput.currentInputP).forEach(k => {\n    internalInput.currentInputP[k] = false;\n  });\n  Object.keys(internalInput.engineCurrentInputP).forEach(k => {\n    internalInput.engineCurrentInputP[k] = false;\n  });\n}\n", "const HUD_COMMANDS = ['Start recording', 'Play recording', 'Stop recording'];\n\nconst COMMAND_BG = '#555555';\nconst COMMAND_FG = '#eeeeee';\n\nfunction setHudBoundingBox(hudElement, boundingBox) {\n  hudElement.style.top = boundingBox.top + 'px';\n  hudElement.style.left = boundingBox.left + 'px';\n  hudElement.style.width = boundingBox.width + 'px';\n  hudElement.style.height = boundingBox.height + 'px';\n}\n\nfunction buildHudElement(boundingBox) {\n  let hudElement = document.createElement('div');\n  hudElement.style.position = 'absolute';\n  setHudBoundingBox(hudElement, boundingBox);\n  hudElement.style.backgroundColor = COMMAND_BG;\n  hudElement.style.opacity = 0;\n  hudElement.style.transition = 'opacity 0.3s ease';\n\n  let hudCommandList = document.createElement('ul');\n  hudCommandList.style.color = COMMAND_FG;\n  hudCommandList.style.listStyle = 'none';\n  hudCommandList.style.padding = '0 20px';\n  hudCommandList.style.marginTop = '40px';\n  hudCommandList.style.fontFamily = 'monospace';\n\n  HUD_COMMANDS.forEach(cmd => {\n    let commandItem = document.createElement('li');\n    commandItem.innerHTML = cmd;\n    commandItem.style.lineHeight = 1.6;\n    commandItem.style.padding = '2px 10px';\n    hudCommandList.appendChild(commandItem);\n  });\n\n  // Highlight the first element\n  hudCommandList.children.item(0).style.backgroundColor = COMMAND_FG;\n  hudCommandList.children.item(0).style.color = COMMAND_BG;\n\n  hudElement.appendChild(hudCommandList);\n\n  return hudElement;\n}\n\n/**\n * Initialize the HUD, create the HTML code\n *\n */\nexport function initHud(canvasBoundingBox) {\n  let hudElement = buildHudElement(canvasBoundingBox);\n  document.body.appendChild(hudElement);\n\n  return {\n    active: false,\n    selectedCommand: 0,\n    element: hudElement,\n  };\n}\n\nexport function toggleHud(hud, canvasBoundingBox) {\n  hud.active = !hud.active;\n  if (hud.active) {\n    setHudBoundingBox(hud.element, canvasBoundingBox);\n  }\n  hud.element.style.opacity = Number(hud.active);\n}\n\nfunction updateHudCommandSelection(hud, input) {\n  // update the selected command if the arrows were pressed\n  let newCommandIndex = hud.selectedCommand;\n\n  if (input.downp) {\n    newCommandIndex = (hud.selectedCommand + 1) % HUD_COMMANDS.length;\n  } else if (input.upp) {\n    newCommandIndex = (hud.selectedCommand - 1 + HUD_COMMANDS.length) % HUD_COMMANDS.length;\n  }\n\n  if (newCommandIndex !== hud.selectedCommand) {\n    let commandList = hud.element.firstChild;\n\n    // remove background of old command\n    commandList.children.item(hud.selectedCommand).style.backgroundColor = null;\n    commandList.children.item(hud.selectedCommand).style.color = COMMAND_FG;\n\n    // set background of new command\n    commandList.children.item(newCommandIndex).style.backgroundColor = COMMAND_FG;\n    commandList.children.item(newCommandIndex).style.color = COMMAND_BG;\n\n    hud.selectedCommand = newCommandIndex;\n  }\n}\n\nexport function updateHud(hud, internalInput, input) {\n  // check if the current command has been selected\n  if (internalInput.enterp) {\n    return hud.selectedCommand;\n  }\n\n  // Otherwise, update the selection if necessary\n  updateHudCommandSelection(hud, input);\n}\n", "const ASSETS_URL = '/assets/';\n\n/**\n * Helper that returns a promise that resolves when all images have finished loaded\n *\n */\nfunction imageLoaded(asset) {\n  return new Promise((resolve, reject) => {\n    if (asset.image.complete) {\n      asset.loaded = true;\n      resolve(asset);\n    } else {\n      asset.image.addEventListener('load', () => {\n        asset.loaded = true;\n        resolve(asset);\n      });\n      asset.image.addEventListener('error', reject);\n    }\n  });\n}\n\n/**\n * Load the game assets. It receives a description of the game assets with the form:\n *\n * {\n *   assetKey: assetPath,\n *   ...\n * }\n *\n * Where `assetKey` is the name by which the asset will be referenced (e.g. env.assets.tree) and\n * `assetPath` is a string with the relative path to the asset file (relative to the `assets-dir`\n * passed to the game-sandbox server\n */\nfunction loadAssets(assets, assetsDescription) {\n  let imageLoadedPromises = [];\n  assets.loaded = false;\n\n  Object.entries(assetsDescription).forEach(([k, v]) => {\n    assets[k] = { loaded: false, image: new Image() };\n    assets[k].image.src = ASSETS_URL + v;\n    imageLoadedPromises.push(imageLoaded(assets[k]));\n  });\n\n  // When all images have been loaded, set the `loaded` flag to true\n  // TODO: Deal with errors\n  Promise.all(imageLoadedPromises).then(() => {\n    assets.loaded = true;\n  });\n}\n\nexport function initAssets() {\n  let assets = {\n    load: assetsDescription => loadAssets(assets, assetsDescription),\n  };\n\n  return assets;\n}\n", "const MAX_RECORDER_SIZE = 60 * 60 * 5; // 60 FPS * 60 secs/min * 5 mins\n\nexport function initRecorder() {\n  return {\n    recording: false,\n    playing: false,\n    currentInput: 0,\n    stateSnapshot: undefined,\n    inputHistory: [],\n  };\n}\n\nexport function startRecording(env, updatedState) {\n  let recorder = env.engine.recorder;\n  recorder.recording = true;\n  recorder.stateSnapshot = updatedState;\n  recorder.playing = false;\n  recorder.currentInput = 0;\n  recorder.stateSnapshot = JSON.parse(JSON.stringify(updatedState));\n  recorder.inputHistory = [];\n}\n\nexport function playRecording(env) {\n  let recorder = env.engine.recorder;\n  stopRecording(env);\n\n  recorder.playing = true;\n  recorder.currentInput = 0;\n}\n\nexport function stopRecording(env) {\n  let recorder = env.engine.recorder;\n  recorder.recording = false;\n}\n\n/**\n * Returns the next entry in the recording's input history and this frame's state, which could be\n * the same as `currentState`, or the initial recorded snapshot if it has reached the beginning of\n * the history.\n *\n */\nexport function playInputHistory(recorder, currentState) {\n  if (!recorder.playing) {\n    throw new Error(`Tried to play input history, but recorder is not playing`);\n  }\n\n  if (recorder.inputHistory.length === 0) {\n    throw new Error(`Recorder input history is empty!!`);\n  }\n\n  let input = recorder.inputHistory[recorder.currentInput];\n  let state = currentState;\n\n  // if we reached the first input entry, reset the state\n  if (recorder.currentInput === 0) {\n    state = JSON.parse(JSON.stringify(recorder.stateSnapshot));\n  }\n\n  // increase the played input\n  recorder.currentInput = (recorder.currentInput + 1) % recorder.inputHistory.length;\n  return { state, input };\n}\n\nexport function recordInput(recorder, input) {\n  if (!recorder.recording) {\n    throw new Error(`Tried to record input, but recorder is not recording`);\n  }\n\n  recorder.inputHistory.push({ ...input });\n\n  // FIXME: Do something about this\n  if (recorder.inputHistory.length > MAX_RECORDER_SIZE) {\n    throw new Error(`Max record input exceeded!!`);\n  }\n}\n\n// export function processRecording(env) {}\n", "import { initInput, readInput, clearFrameInput } from './input.js';\nimport { initHud, toggleHud, updateHud } from './hud.js';\nimport { initAssets } from './assets.js';\nimport {\n  initRecorder,\n  startRecording,\n  playRecording,\n  stopRecording,\n  playInputHistory,\n  recordInput,\n} from './recorder.js';\n\nconst OPT_DEFAULTS = {\n  width: 600,\n  height: 600,\n  canvasId: 'canvas',\n};\n\n/**\n * Initializes the internal data in the environment\n *\n */\nfunction initEngine(canvasEl) {\n  return {\n    initialized: false,\n    recorder: initRecorder(),\n    input: initInput(),\n    hud: initHud(canvasEl.getBoundingClientRect()),\n    canvasEl,\n  };\n}\n\n/**\n * Initialize the environment\n *\n *  - Set the canvas size\n *  - Store the canvas context\n *  - Initialize environment data\n *  - Register keyboard handlers\n */\nfunction initEnv(opts) {\n  let { width, height, canvasId } = opts;\n\n  let canvasEl = document.getElementById(canvasId);\n  let ctx = canvasEl.getContext('2d');\n\n  // Scale the ctx to respect the pixel ratio\n  let dpr = window.devicePixelRatio || 1;\n\n  canvasEl.width = width * dpr;\n  canvasEl.height = height * dpr;\n\n  canvasEl.style.width = width + 'px';\n  canvasEl.style.height = height + 'px';\n\n  ctx.scale(dpr, dpr);\n\n  return {\n    ctx,\n    width,\n    height,\n    input: {},\n    delta: 0,\n    engine: initEngine(canvasEl),\n    assets: initAssets(),\n  };\n}\n\n/**\n * Declares the game loop and starts it\n *\n */\nfunction initGame(state, env) {\n  let updatedState = state;\n  let lastTime = 0;\n\n  let hud = env.engine.hud;\n  let canvasEl = env.engine.canvasEl;\n  let recorder = env.engine.recorder;\n\n  (function gameLoop(time) {\n    // Calculate how many milliseconds passed since last frame\n    env.delta = (time - lastTime) / 1000;\n\n    // Read this frame's input\n    readInput(env);\n\n    // if we are playing a recording, overwrite the parts of the input that affect the game\n    if (recorder.playing && !hud.active) {\n      // playInputHistory may force an state update when it has reached the end of the record and\n      // needs to loop to the beginning\n      let { state, input } = playInputHistory(env.engine.recorder, updatedState, env.input);\n\n      // Update the input and state based on the recording\n      updatedState = state;\n      env.input = input;\n    }\n\n    if (recorder.recording && !hud.active) {\n      recordInput(recorder, env.input);\n    }\n\n    if (env.engine.internalInput.hudp) {\n      toggleHud(hud, canvasEl.getBoundingClientRect());\n    }\n\n    if (hud.active) {\n      // If hud is open, do not draw the game, instead process hud events\n      let selectedCommand = updateHud(hud, env.engine.internalInput, env.input);\n      if (selectedCommand !== undefined) {\n        // A command was executed\n        // Deactivate hud\n        toggleHud(hud, canvasEl.getBoundingClientRect());\n        // Apply command\n        // FIXME: This requires knowledge of HUD Commands. Instead, register functions or something\n        // like that?\n        if (selectedCommand === 0) {\n          // start recording\n          startRecording(env, updatedState);\n        } else if (selectedCommand === 1) {\n          // stop recording and play\n          playRecording(env);\n          updatedState = JSON.parse(JSON.stringify(recorder.stateSnapshot));\n        } else if (selectedCommand === 2) {\n          stopRecording(env);\n        }\n      }\n    } else {\n      // Run user's defined draw function\n      updatedState = env.engine.draw(updatedState, env);\n    }\n\n    // Clear transient input for this frame\n    clearFrameInput(env.engine.input);\n    lastTime = time;\n    window.requestAnimationFrame(gameLoop);\n  })(0);\n}\n\n/**\n * Create a new web socket connection to the server, passing the entry point of the game. When the\n * server detects a change and notifies through the websocket, re-import a new version of the module\n * and replace the draw / setup functions with the updated ones.\n *\n */\nfunction startGameClient(moduleUrl, env) {\n  let protocol = location.protocol === 'https' ? 'wss' : 'ws';\n  let ws = new WebSocket(`${protocol}://${location.host}?module=${moduleUrl}`);\n\n  ws.addEventListener('message', async event => {\n    let [action, file] = event.data.split(':');\n\n    if (action === 'change' || action === 'rebuild') {\n      // When a chage is detected, re-import the game bundle\n\n      // The try block is just to silence esbuild when bundling the distributable\n      let module;\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        module = await import(file + '?t=' + new Date().getTime());\n      } catch (e) {\n        throw e;\n      }\n\n      if (!module.setup || !module.draw) {\n        throw new Error(`Invalid module at ${file}`);\n      }\n\n      let engine = env.engine;\n\n      // Update the setup / draw functions with the new ones\n      engine.setup = module.setup;\n      engine.draw = module.draw;\n\n      // After the first update, if the client was not initialized, we start the game\n      if (!engine.initialized) {\n        let state = engine.setup(env);\n\n        engine.initialized = true;\n        // game loop\n        initGame(state, env);\n      }\n    }\n  });\n}\n\n/**\n * Starts the game. Options\n *\n *   witdth:    The game width\n *   height:    The game height\n *   canvasId:  The id of the HTML canvas element\n *   moduleUrl: The path to the game module entry point (relative to the watch-dir parameter)\n *\n */\nexport function runGame(opts) {\n  opts = Object.assign({}, OPT_DEFAULTS, opts);\n\n  if (!opts.moduleUrl) {\n    throw new Error(`Must provide a moduleUrl`);\n  }\n\n  // wait until the DOM is loaded, then start\n  window.addEventListener('load', () => {\n    let env = initEnv(opts);\n    startGameClient(opts.moduleUrl, env);\n  });\n}\n", "/**\n * Draw the current state of an animation, and update it\n *\n * parameters:\n *  - animation: The animation object, as returned by `createAnimation`\n *  - x, y:      The coordinates where to draw the animation\n *  - width:     The destination image width\n *  - height:    The destination image height\n *  - assets:    The assets object\n *  - delta:     The time passed since last frame draw\n *  - ctx:       The context object\n *  - flip:      Wheter to draw this animation flipped\n */\n// FIXME: Can we reduce the number of computations every draw cycle?\nexport function drawAnimation(animation, x, y, width, height, assets, delta, ctx, flip = false) {\n  let asset = assets[animation.assetName];\n  if (!asset || !asset.loaded) {\n    throw new Error(`Asset ${animation.assetName} not loaded!!!`);\n  }\n\n  animation.time += delta;\n  // FIXME: This assumes looping always\n  if (animation.time > animation.timePerFrame) {\n    animation.time = 0;\n    animation.currentFrame = (animation.currentFrame + 1) % animation.frames.length;\n  }\n\n  let columns = asset.image.width / animation.width;\n\n  let frameIndex = animation.frames[animation.currentFrame];\n\n  let sourceY = Math.trunc(frameIndex / columns) * animation.height; //96;\n  let sourceX = (frameIndex % columns) * animation.width; //96;\n\n  if (flip) {\n    x += width;\n  }\n\n  ctx.save();\n  ctx.translate(x, y);\n  if (flip) {\n    ctx.scale(-1, 1);\n  }\n\n  ctx.drawImage(\n    asset.image,\n    sourceX,\n    sourceY,\n    animation.width,\n    animation.height,\n    0,\n    0,\n    width,\n    height\n  );\n\n  ctx.restore();\n}\n\n/**\n * Creates a new animation object that can be stored in the state\n */\nexport function createAnimation(assetName, { width, height, speed, loop, frames }) {\n  return {\n    currentFrame: 0,\n    time: 0,\n    assetName,\n    loop,\n    width,\n    height,\n    frames,\n    timePerFrame: 1 / speed,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
