{
  "version": 3,
  "sources": ["../lib/input.js", "../lib/hud.js", "../lib/engine.js"],
  "sourcesContent": ["// KeyboardEvent#code -> input key\nconst KEY_MAP = {\n  ArrowRight: 'right',\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  KeyX: 'b1',\n  KeyZ: 'b2',\n  Backquote: 'hud',\n  Enter: 'enter',\n};\n\n/**\n * Register input event handlers\n *\n */\nexport function initInput() {\n  let currentInput = {};\n  let currentInputP = {};\n\n  document.addEventListener('keydown', e => {\n    let key = KEY_MAP[e.code];\n    let keyp = key + 'p';\n\n    if (!key) return;\n\n    currentInput[key] = true;\n    currentInputP[keyp] = true;\n  });\n\n  document.addEventListener('keyup', e => {\n    let key = KEY_MAP[e.code];\n    if (!key) return;\n    currentInput[key] = false;\n  });\n\n  return {\n    currentInput,\n    currentInputP,\n  };\n}\n\n/**\n * Copy the transient input (as read from the DOM) into the env input.\n *\n */\nexport function readInput(env) {\n  let internalInput = env.engine.input;\n  env.input = Object.assign({}, internalInput.currentInput, internalInput.currentInputP);\n}\n\n/**\n * Set all input keypresses to false, so that attribute can be used to detect the frame when the\n * key was initially pressed.\n *\n */\nexport function clearFrameInput(internalInput) {\n  Object.keys(internalInput.currentInputP).forEach(k => {\n    internalInput.currentInputP[k] = false;\n  });\n}\n", "const HUD_COMMANDS = ['Toggle FPS', 'Take state snapshot', 'Load state snapshot'];\n\nconst COMMAND_BG = '#555555';\nconst COMMAND_FG = '#eeeeee';\n\nfunction setHudBoundingBox(hudElement, boundingBox) {\n  hudElement.style.top = boundingBox.top + 'px';\n  hudElement.style.left = boundingBox.left + 'px';\n  hudElement.style.width = boundingBox.width + 'px';\n  hudElement.style.height = boundingBox.height + 'px';\n}\n\nfunction buildHudElement(boundingBox) {\n  let hudElement = document.createElement('div');\n  hudElement.style.position = 'absolute';\n  setHudBoundingBox(hudElement, boundingBox);\n  hudElement.style.backgroundColor = COMMAND_BG;\n  hudElement.style.opacity = 0;\n  hudElement.style.transition = 'opacity 0.3s ease';\n\n  let hudCommandList = document.createElement('ul');\n  hudCommandList.style.color = COMMAND_FG;\n  hudCommandList.style.listStyle = 'none';\n  hudCommandList.style.padding = '0 20px';\n  hudCommandList.style.marginTop = '40px';\n  hudCommandList.style.fontFamily = 'monospace';\n\n  HUD_COMMANDS.forEach(cmd => {\n    let commandItem = document.createElement('li');\n    commandItem.innerHTML = cmd;\n    commandItem.style.lineHeight = 1.6;\n    commandItem.style.padding = '2px 10px';\n    hudCommandList.appendChild(commandItem);\n  });\n\n  // Highlight the first element\n  hudCommandList.children.item(0).style.backgroundColor = COMMAND_FG;\n  hudCommandList.children.item(0).style.color = COMMAND_BG;\n\n  hudElement.appendChild(hudCommandList);\n\n  return hudElement;\n}\n\n/**\n * Initialize the HUD, create the HTML code\n *\n */\nexport function initHud(canvasBoundingBox) {\n  let hudElement = buildHudElement(canvasBoundingBox);\n  document.body.appendChild(hudElement);\n\n  return {\n    active: false,\n    selectedCommand: 0,\n    element: hudElement,\n  };\n}\n\nexport function toggleHud(hud, canvasBoundingBox) {\n  hud.active = !hud.active;\n  if (hud.active) {\n    setHudBoundingBox(hud.element, canvasBoundingBox);\n  }\n  hud.element.style.opacity = Number(hud.active);\n}\n\nfunction updateHudCommandSelection(hud, input) {\n  // update the selected command if the arrows were pressed\n  let newCommandIndex = hud.selectedCommand;\n\n  if (input.downp) {\n    newCommandIndex = (hud.selectedCommand + 1) % HUD_COMMANDS.length;\n  } else if (input.upp) {\n    newCommandIndex = (hud.selectedCommand - 1 + HUD_COMMANDS.length) % HUD_COMMANDS.length;\n  }\n\n  if (newCommandIndex !== hud.selectedCommand) {\n    let commandList = hud.element.firstChild;\n\n    // remove background of old command\n    commandList.children.item(hud.selectedCommand).style.backgroundColor = null;\n    commandList.children.item(hud.selectedCommand).style.color = COMMAND_FG;\n\n    // set background of new command\n    commandList.children.item(newCommandIndex).style.backgroundColor = COMMAND_FG;\n    commandList.children.item(newCommandIndex).style.color = COMMAND_BG;\n\n    hud.selectedCommand = newCommandIndex;\n  }\n}\n\nexport function updateHud(hud, input) {\n  // check if the current command has been selected\n  if (input.enterp) {\n    return hud.selectedCommand;\n  }\n\n  // Otherwise, update the selection if necessary\n  updateHudCommandSelection(hud, input);\n}\n", "import { initInput, readInput, clearFrameInput } from './input.js';\nimport { initHud, toggleHud, updateHud } from './hud.js';\n\nconst OPT_DEFAULTS = {\n  width: 600,\n  height: 600,\n  canvasId: 'canvas',\n};\n\n/**\n * Initializes the internal data in the environment\n *\n */\nfunction initEngine(canvasEl) {\n  return {\n    initialized: false,\n    input: initInput(),\n    hud: initHud(canvasEl.getBoundingClientRect()),\n    canvasEl,\n  };\n}\n\n/**\n * Initialize the environment\n *\n *  - Set the canvas size\n *  - Store the canvas context\n *  - Initialize environment data\n *  - Register keyboard handlers\n */\nfunction initEnv(opts) {\n  let { width, height, canvasId } = opts;\n\n  let canvasEl = document.getElementById(canvasId);\n  let ctx = canvasEl.getContext('2d');\n\n  // Scale the ctx to respect the pixel ratio\n  let dpr = window.devicePixelRatio || 1;\n\n  canvasEl.width = width * dpr;\n  canvasEl.height = height * dpr;\n\n  canvasEl.style.width = width + 'px';\n  canvasEl.style.height = height + 'px';\n\n  ctx.scale(dpr, dpr);\n\n  return {\n    ctx,\n    width,\n    height,\n    input: {},\n    delta: 0,\n    engine: initEngine(canvasEl),\n  };\n}\n\n/**\n * Declares the game loop and starts it\n *\n */\nfunction initGame(state, env) {\n  let updatedState = state;\n  let lastTime = 0;\n\n  let hud = env.engine.hud;\n  let canvasEl = env.engine.canvasEl;\n\n  (function gameLoop(time) {\n    // Calculate how many milliseconds passed since last frame\n    env.delta = (time - lastTime) / 1000;\n\n    // Read this frame's input\n    readInput(env);\n\n    if (env.input.hudp) {\n      toggleHud(hud, canvasEl.getBoundingClientRect());\n    }\n\n    if (hud.active) {\n      // If hud is open, do not draw the game, instead process hud events\n      let selectedCommand = updateHud(hud, env.input);\n      if (selectedCommand !== undefined) {\n        // A command was executed\n        // Deactivate hud\n        toggleHud(hud, canvasEl.getBoundingClientRect());\n        // Apply command\n        // FIXME: This requires knowledge of HUD Commands. Instead, register functions or something\n        // like that?\n        console.log('COMMMAND!', selectedCommand);\n      }\n    } else {\n      // Run user's defined draw function\n      updatedState = env.engine.draw(updatedState, env);\n    }\n\n    // Clear transient input for this frame\n    clearFrameInput(env.engine.input);\n    lastTime = time;\n    window.requestAnimationFrame(gameLoop);\n  })(0);\n}\n\n/**\n * Create a new web socket connection to the server, passing the entry point of the game. When the\n * server detects a change and notifies through the websocket, re-import a new version of the module\n * and replace the draw / setup functions with the updated ones.\n *\n */\nfunction startGameClient(moduleUrl, env) {\n  let protocol = location.protocol === 'https' ? 'wss' : 'ws';\n  let ws = new WebSocket(`${protocol}://${location.host}?module=${moduleUrl}`);\n\n  ws.addEventListener('message', async event => {\n    let [action, file] = event.data.split(':');\n\n    if (action === 'change' || action === 'rebuild') {\n      // When a chage is detected, re-import the game bundle\n\n      // The try block is just to silence esbuild when bundling the distributable\n      let module;\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        module = await import(file + '?t=' + new Date().getTime());\n      } catch (e) {\n        throw e;\n      }\n\n      if (!module.setup || !module.draw) {\n        throw new Error(`Invalid module at ${file}`);\n      }\n\n      let engine = env.engine;\n\n      // Update the setup / draw functions with the new ones\n      engine.setup = module.setup;\n      engine.draw = module.draw;\n\n      // After the first update, if the client was not initialized, we start the game\n      if (!engine.initialized) {\n        let state = engine.setup(env);\n\n        engine.initialized = true;\n        // game loop\n        initGame(state, env);\n      }\n    }\n  });\n}\n\n/**\n * Starts the game. Options\n *\n *   witdth:    The game width\n *   height:    The game height\n *   canvasId:  The id of the HTML canvas element\n *   moduleUrl: The path to the game module entry point (relative to the watch-dir parameter)\n *\n */\nexport async function runGame(opts) {\n  opts = Object.assign({}, OPT_DEFAULTS, opts);\n\n  if (!opts.moduleUrl) {\n    throw new Error(`Must provide a moduleUrl`);\n  }\n\n  // wait until the DOM is loaded, then start\n  window.addEventListener('load', () => {\n    let env = initEnv(opts);\n    startGameClient(opts.moduleUrl, env);\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
