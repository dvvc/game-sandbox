{
  "version": 3,
  "sources": ["../lib/input.js", "../lib/engine.js"],
  "sourcesContent": ["// KeyboardEvent#code -> input key\nconst KEY_MAP = {\n  ArrowRight: 'right',\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  KeyX: 'b1',\n  KeyZ: 'b2',\n  Backquote: 'hud',\n};\n\n/**\n * Register input event handlers\n *\n */\nexport function initInput() {\n  let currentInput = {};\n  let currentInputP = {};\n\n  document.addEventListener('keydown', e => {\n    let key = KEY_MAP[e.code];\n    let keyp = key + 'p';\n\n    if (!key) return;\n\n    currentInput[key] = true;\n    currentInputP[keyp] = true;\n  });\n\n  document.addEventListener('keyup', e => {\n    let key = KEY_MAP[e.code];\n    if (!key) return;\n    currentInput[key] = false;\n  });\n\n  return {\n    currentInput,\n    currentInputP,\n  };\n}\n\n/**\n * Copy the transient input (as read from the DOM) into the env input.\n *\n */\nexport function readInput(internalInput, env) {\n  env.input = Object.assign({}, internalInput.currentInput, internalInput.currentInputP);\n}\n\n/**\n * Set all input keypresses to false, so that attribute can be used to detect the frame when the\n * key was initially pressed.\n *\n */\nexport function clearFrameInput(internalInput) {\n  Object.keys(internalInput.currentInputP).forEach(k => {\n    internalInput.currentInputP[k] = false;\n  });\n}\n", "import { initInput, readInput, clearFrameInput } from './input.js';\n\nconst OPT_DEFAULTS = {\n  width: 600,\n  height: 600,\n  canvasId: 'canvas',\n};\n\n/**\n * Initializes the game engine\n *  - Register keyboard handlers\n */\nfunction initEngine() {\n  return {\n    initialized: false,\n    input: initInput(),\n  };\n}\n\n/**\n * Initialize the environment\n *\n *  - Set the canvas size\n *  - Store the canvas context\n *  - Initialize environment data\n *\n */\nfunction initEnv(opts) {\n  let { width, height, canvasId } = opts;\n\n  let canvasEl = document.getElementById(canvasId);\n  let ctx = canvasEl.getContext('2d');\n\n  // Scale the ctx to respect the pixel ratio\n  let dpr = window.devicePixelRatio || 1;\n\n  canvasEl.width = width * dpr;\n  canvasEl.height = height * dpr;\n\n  canvasEl.style.width = width + 'px';\n  canvasEl.style.height = height + 'px';\n\n  ctx.scale(dpr, dpr);\n\n  return {\n    ctx,\n    width,\n    height,\n    input: {},\n    delta: 0,\n  };\n}\n\n/**\n * Declares the game loop and starts it\n *\n */\nfunction initGame(state, engine, env) {\n  let updatedState = state;\n  let lastTime = 0;\n\n  (function gameLoop(time) {\n    // Calculate how many milliseconds passed since last frame\n    env.delta = (time - lastTime) / 1000;\n\n    // Read this frame's input\n    readInput(engine.input, env);\n\n    // Run user's defined draw function\n    updatedState = engine.draw(updatedState, env);\n\n    // Clear transient input for this frame\n    clearFrameInput(engine.input);\n    lastTime = time;\n    window.requestAnimationFrame(gameLoop);\n  })(0);\n}\n\n/**\n * Create a new web socket connection to the server, passing the entry point of the game. When the\n * server detects a change and notifies through the websocket, re-import a new version of the module\n * and replace the draw / setup functions with the updated ones.\n *\n */\nfunction startGameClient(moduleUrl, engine, env) {\n  let protocol = location.protocol === 'https' ? 'wss' : 'ws';\n  let ws = new WebSocket(`${protocol}://${location.host}?module=${moduleUrl}`);\n\n  ws.addEventListener('message', async event => {\n    let [action, file] = event.data.split(':');\n\n    if (action === 'change' || action === 'rebuild') {\n      // When a chage is detected, re-import the game bundle\n\n      // The try block is just to silence esbuild when bundling the distributable\n      let module;\n\n      // eslint-disable-next-line no-useless-catch\n      try {\n        module = await import(file + '?t=' + new Date().getTime());\n      } catch (e) {\n        throw e;\n      }\n\n      if (!module.setup || !module.draw) {\n        throw new Error(`Invalid module at ${file}`);\n      }\n\n      // Update the setup / draw functions with the new ones\n      engine.setup = module.setup;\n      engine.draw = module.draw;\n\n      // After the first update, if the client was not initialized, we start the game\n      if (!engine.initialized) {\n        let state = engine.setup(env);\n\n        engine.initialized = true;\n        // game loop\n        initGame(state, engine, env);\n      }\n    }\n  });\n}\n\n/**\n * Starts the game. Options\n *\n *   witdth:    The game width\n *   height:    The game height\n *   canvasId:  The id of the HTML canvas element\n *   moduleUrl: The path to the game module entry point (relative to the watch-dir parameter)\n *\n */\nexport async function runGame(opts) {\n  opts = Object.assign({}, OPT_DEFAULTS, opts);\n\n  if (!opts.moduleUrl) {\n    throw new Error(`Must provide a moduleUrl`);\n  }\n\n  // wait until the DOM is loaded, then start\n  window.addEventListener('load', () => {\n    let engine = initEngine();\n    let env = initEnv(opts);\n    startGameClient(opts.moduleUrl, engine, env);\n  });\n}\n"],
  "mappings": ";AACA,IAAM,UAAU;AAAA,EACd,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,WAAW;AAAA,EACX,WAAW;AAAA,EACX,MAAM;AAAA,EACN,MAAM;AAAA,EACN,WAAW;AAAA;AAON;AACL,MAAI,eAAe;AACnB,MAAI,gBAAgB;AAEpB,WAAS,iBAAiB,WAAW;AACnC,QAAI,MAAM,QAAQ,EAAE;AACpB,QAAI,OAAO,MAAM;AAEjB,QAAI,CAAC;AAAK;AAEV,iBAAa,OAAO;AACpB,kBAAc,QAAQ;AAAA;AAGxB,WAAS,iBAAiB,SAAS;AACjC,QAAI,MAAM,QAAQ,EAAE;AACpB,QAAI,CAAC;AAAK;AACV,iBAAa,OAAO;AAAA;AAGtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA;AAAA;AAQG,mBAAmB,eAAe;AACvC,MAAI,QAAQ,OAAO,OAAO,IAAI,cAAc,cAAc,cAAc;AAAA;AAQnE,yBAAyB;AAC9B,SAAO,KAAK,cAAc,eAAe,QAAQ;AAC/C,kBAAc,cAAc,KAAK;AAAA;AAAA;;;ACtDrC,IAAM,eAAe;AAAA,EACnB,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,UAAU;AAAA;AAOZ;AACE,SAAO;AAAA,IACL,aAAa;AAAA,IACb,OAAO;AAAA;AAAA;AAYX,iBAAiB;AACf,MAAI,CAAE,OAAO,QAAQ,YAAa;AAElC,MAAI,WAAW,SAAS,eAAe;AACvC,MAAI,MAAM,SAAS,WAAW;AAG9B,MAAI,MAAM,OAAO,oBAAoB;AAErC,WAAS,QAAQ,QAAQ;AACzB,WAAS,SAAS,SAAS;AAE3B,WAAS,MAAM,QAAQ,QAAQ;AAC/B,WAAS,MAAM,SAAS,SAAS;AAEjC,MAAI,MAAM,KAAK;AAEf,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,OAAO;AAAA;AAAA;AAQX,kBAAkB,OAAO,QAAQ;AAC/B,MAAI,eAAe;AACnB,MAAI,WAAW;AAEf,EAAC,mBAAkB;AAEjB,QAAI,QAAS,QAAO,YAAY;AAGhC,cAAU,OAAO,OAAO;AAGxB,mBAAe,OAAO,KAAK,cAAc;AAGzC,oBAAgB,OAAO;AACvB,eAAW;AACX,WAAO,sBAAsB;AAAA,KAC5B;AAAA;AASL,yBAAyB,WAAW,QAAQ;AAC1C,MAAI,WAAW,SAAS,aAAa,UAAU,QAAQ;AACvD,MAAI,KAAK,IAAI,UAAU,GAAG,cAAc,SAAS,eAAe;AAEhE,KAAG,iBAAiB,WAAW,OAAM;AACnC,QAAI,CAAC,QAAQ,QAAQ,MAAM,KAAK,MAAM;AAEtC,QAAI,WAAW,YAAY,WAAW;AAIpC,UAAI;AAGJ;AACE,iBAAS,MAAa,cAAO,QAAQ,IAAI,OAAO;AAAA,eACzC;AACP,cAAM;AAAA;AAGR,UAAI,CAAC,OAAO,SAAS,CAAC,OAAO;AAC3B,cAAM,IAAI,MAAM,qBAAqB;AAAA;AAIvC,aAAO,QAAQ,OAAO;AACtB,aAAO,OAAO,OAAO;AAGrB,UAAI,CAAC,OAAO;AACV,YAAI,QAAQ,OAAO,MAAM;AAEzB,eAAO,cAAc;AAErB,iBAAS,OAAO,QAAQ;AAAA;AAAA;AAAA;AAAA;AAehC,uBAA8B;AAC5B,SAAO,OAAO,OAAO,IAAI,cAAc;AAEvC,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM;AAAA;AAIlB,SAAO,iBAAiB,QAAQ;AAC9B,QAAI,SAAS;AACb,QAAI,MAAM,QAAQ;AAClB,oBAAgB,KAAK,WAAW,QAAQ;AAAA;AAAA;",
  "names": []
}
