#+TODO: TODO FIXME IDEA CURRENT | DONE FIXED CANCELLED

* Version 1
** DONE Load game in an existing canvas by ID
** DONE Game loop, separate state
** DONE Load game library as an external module
** DONE Detect game code changes, trigger reload
** DONE Support keyboard input
** DONE How to handle multiple game files that change?
** DONE Add a linter
** DONE Publish to npm
** DONE Add code documentation, clean up
** FIXED Error resolving relative directories when executing ./node_modules/.bin/game-sandbox
** FIXED The out.js bundle is created inside node_modules (should be configurable?)
   --- But how to serve it then?
** FIXED dynamic import issue?
   node_modules/game-sandbox/lib/index.js: warning: This dynamic import will not be bundled because the argument
   is not a string literal (surround with a try/catch to silence this warning)
** DONE Decouple ~baseDir~ and ~watchDir~ (??)
** DONE Register with the 'load' event inside ~runGame~
** DONE Serve the actual game-sandbox.js (rather than having to copy it manually)
** DONE Support for secure web sockets
** DONE Rewrite the README in markdown because NPMJS.com doesn't like org mode
** DONE Implement an in-game menu for built-in functions (FPS, state mgmt...)
** DONE Try / document game-sandbox in Glitch
   - Conclusion: Glitch is, surprisingly, not a good fit for this library. The main problem found is
     it too eager when detecting changes to the source. This results in the game reloading too
     often, and when it's in an error state (e.g., when in the middle of typing a command)
   - A better alternative would be a web editor (plus server) that does not autosave
** DONE Write documentation on how to use the library
   - Is it a requirement to use ESM? Since the dist bundle uses it?
   - Document directory structure: baseDir / watchDir / outputDir
   - Loading game-sandbox.js
   - Document the user-facing functions and data structures (env, draw, setup, state)
   - Ejecting
** DONE Recalculate canvas BB every time HUD is toggled on
   - Currently, resizing the screen after starting the engine causes the HUD to be misplaced
** DONE Record / loop state / go back
** DONE Load game assets
** DONE Animations
** TODO Hot reload of game assets
** TODO Manage the canvas parent, so we can have proper HUDs
** TODO Replay in slow motion
** TODO Play frame by frame
** TODO Support gamepad input
** TODO Introspect state (while playing frame-by-frame)
** TODO Add timers
** TODO Text rendering
** TODO Implement the ~init~ cli function
** TODO Abstract UI widgets so we don't have to write HTML
** TODO Handle esbuild errors gracefully (e.g. notify client?)
** TODO When there's an error, the client should not keep going. Also, how to recover?
** TODO Game tools (blit image, etc)
** FIXME Can we be loading stale ~out.js~ from a previously existing dist??
** TODO Detect changes to initial state and do a full reload
** TODO The ~runGame~ moduleUrl parameter is confusing
** FIXME Detect clashes with made up ~build~ url if the base dir has a ~build~ subdirectory
** FIXME Reposition HUD when window changes size
** TODO Make it easier to add animations
   - Right now, the user needs to define all the possible animations (for each entity) and then keep
     track of which one is active.
** TODO Improve animations interface
   - The interface is not easy to use, drawAnimation takes a lot of parameters


* Version 2
** TODO Use WebGL
** TODO Support loading assets in chunks (e.g. loading screen assets, 1st screen assets, ...)
** TODO [#C] Add parameter to exclude files from watcher
** TODO Figure out a way to deal with external imports / modules
   We want game-sandbox to provide some functions to help development, such as drawing animated
   assets, etc. Users of the library would import those libraries in their code, e.g.:
   ~import { assets } from '/game-sandbox.js'~. However, since user code is bundled by ESBuild, it
   will try to resolve that kind of import **at build time** rather than at runtime.

   One solution is to mark ~/game-sandbox.js~ as an external library, so that ESBuild does not try to
   bundle it. Another way would be to use a build time import like ~import { assets } from
   'game-sandbox'~, however this is weird because we are already importing '/game-sandbox.js' to get
   runGame and it would be confusing.

   Another solution would be to provide a different module / npm package for utilities, so we don't
   mix things.
